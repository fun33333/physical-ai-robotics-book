"use strict";(globalThis.webpackChunkbook_website=globalThis.webpackChunkbook_website||[]).push([[7249],{7142:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-2/simulation-fundamentals","title":"Simulation Fundamentals","description":"Core concepts of robotics simulation: physics engines, sensor modeling, and sim-to-real transfer.","source":"@site/docs/module-2/simulation-fundamentals.md","sourceDirName":"module-2","slug":"/module-2/simulation-fundamentals","permalink":"/physical-ai-robotics-book/docs/module-2/simulation-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/fun33333/physical-ai-robotics-book/tree/main/book-website/docs/module-2/simulation-fundamentals.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Simulation Fundamentals","sidebar_position":2,"description":"Core concepts of robotics simulation: physics engines, sensor modeling, and sim-to-real transfer."},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: The Digital Twin (Gazebo & Unity)","permalink":"/physical-ai-robotics-book/docs/module-2/"},"next":{"title":"Gazebo Basics","permalink":"/physical-ai-robotics-book/docs/module-2/gazebo-basics"}}');var r=i(4848),t=i(8453);const a={title:"Simulation Fundamentals",sidebar_position:2,description:"Core concepts of robotics simulation: physics engines, sensor modeling, and sim-to-real transfer."},l="Simulation Fundamentals",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"What is Robotics Simulation?",id:"what-is-robotics-simulation",level:2},{value:"Definition",id:"definition",level:3},{value:"Simulation Loop",id:"simulation-loop",level:3},{value:"Real-Time Factor",id:"real-time-factor",level:3},{value:"Physics Engines",id:"physics-engines",level:2},{value:"How Physics Engines Work",id:"how-physics-engines-work",level:3},{value:"Common Physics Engines",id:"common-physics-engines",level:3},{value:"Physics Engine Trade-offs",id:"physics-engine-trade-offs",level:3},{value:"Simulation Step Size",id:"simulation-step-size",level:3},{value:"Sensor Modeling",id:"sensor-modeling",level:2},{value:"Sensor Model Components",id:"sensor-model-components",level:3},{value:"Camera Simulation",id:"camera-simulation",level:3},{value:"LiDAR Simulation",id:"lidar-simulation",level:3},{value:"IMU Simulation",id:"imu-simulation",level:3},{value:"Domain Randomization",id:"domain-randomization",level:2},{value:"What is Domain Randomization?",id:"what-is-domain-randomization",level:3},{value:"Types of Randomization",id:"types-of-randomization",level:3},{value:"Implementation Example",id:"implementation-example",level:3},{value:"Curriculum Learning",id:"curriculum-learning",level:3},{value:"Sim-to-Real Transfer",id:"sim-to-real-transfer",level:2},{value:"The Reality Gap",id:"the-reality-gap",level:3},{value:"Transfer Techniques",id:"transfer-techniques",level:3},{value:"Choosing Simulation Fidelity",id:"choosing-simulation-fidelity",level:2},{value:"Fidelity Levels",id:"fidelity-levels",level:3},{value:"Matching Fidelity to Task",id:"matching-fidelity-to-task",level:3},{value:"Exercise 1: Sensor Noise Analysis",id:"exercise-1-sensor-noise-analysis",level:2},{value:"Exercise 2: Domain Randomization Experiment",id:"exercise-2-domain-randomization-experiment",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function c(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"simulation-fundamentals",children:"Simulation Fundamentals"})}),"\n",(0,r.jsx)(e.p,{children:"Before diving into specific simulators, it's essential to understand what makes a simulation useful for robotics and AI development. This chapter covers the fundamental concepts that apply across all simulation platforms."}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"In this section, you will:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Understand physics engine architectures and trade-offs"}),"\n",(0,r.jsx)(e.li,{children:"Learn sensor modeling approaches and noise characteristics"}),"\n",(0,r.jsx)(e.li,{children:"Explore domain randomization for robust AI training"}),"\n",(0,r.jsx)(e.li,{children:"Master sim-to-real transfer techniques"}),"\n",(0,r.jsx)(e.li,{children:"Choose appropriate simulation fidelity for your use case"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(e.p,{children:"Before starting, ensure you have completed:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"/docs/module-1",children:"Module 1: ROS 2 Fundamentals"})}),"\n",(0,r.jsx)(e.li,{children:"Basic understanding of coordinate frames and transformations"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"what-is-robotics-simulation",children:"What is Robotics Simulation?"}),"\n",(0,r.jsx)(e.h3,{id:"definition",children:"Definition"}),"\n",(0,r.jsx)(e.p,{children:"A robotics simulation is a software system that models:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Robot kinematics"}),": How joints move and affect end-effector position"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Robot dynamics"}),": How forces and torques affect motion"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sensors"}),": What the robot perceives about its environment"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Environment"}),": The world the robot operates in"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physics"}),": Interactions between robot, objects, and environment"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"simulation-loop",children:"Simulation Loop"}),"\n",(0,r.jsx)(e.p,{children:"Every simulator runs a core loop:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Simulation Loop                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n\u2502   \u2502  Read    \u2502    \u2502  Physics \u2502    \u2502  Sensor  \u2502             \u2502\n\u2502   \u2502 Commands \u2502\u2500\u2500\u2500\u25b6\u2502   Step   \u2502\u2500\u2500\u2500\u25b6\u2502  Update  \u2502             \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2502        \u2502                                  \u2502                  \u2502\n\u2502        \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502                  \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  Render  \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502\n\u2502                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \u2502\n\u2502                       \u2502                                      \u2502\n\u2502                       \u25bc                                      \u2502\n\u2502               [Next Time Step]                               \u2502\n\u2502                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h3,{id:"real-time-factor",children:"Real-Time Factor"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.strong,{children:"real-time factor (RTF)"})," measures simulation speed:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"RTF = 1.0: Simulation runs at real-world speed"}),"\n",(0,r.jsx)(e.li,{children:"RTF > 1.0: Simulation runs faster than real-time"}),"\n",(0,r.jsx)(e.li,{children:"RTF < 1.0: Simulation runs slower than real-time"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="Calculating RTF"',children:"rtf = simulation_elapsed_time / wall_clock_time\n\n# Example: 10 simulated seconds in 5 wall-clock seconds\nrtf = 10.0 / 5.0  # RTF = 2.0 (2x faster than real-time)\n"})}),"\n",(0,r.jsx)(e.admonition,{title:"Training Speed",type:"tip",children:(0,r.jsx)(e.p,{children:"For AI training, higher RTF is better. NVIDIA Isaac Sim can achieve RTF > 10,000 for simple physics on modern GPUs."})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,r.jsx)(e.h3,{id:"how-physics-engines-work",children:"How Physics Engines Work"}),"\n",(0,r.jsx)(e.p,{children:"Physics engines compute how objects move and interact:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Collision detection"}),": Determine which objects are touching"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Contact resolution"}),": Calculate forces at contact points"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Constraint solving"}),": Apply joint constraints, friction"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Integration"}),": Update positions and velocities"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"common-physics-engines",children:"Common Physics Engines"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Engine"}),(0,r.jsx)(e.th,{children:"Strengths"}),(0,r.jsx)(e.th,{children:"Used By"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"ODE"})}),(0,r.jsx)(e.td,{children:"Stable, well-tested"}),(0,r.jsx)(e.td,{children:"Gazebo (default)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Bullet"})}),(0,r.jsx)(e.td,{children:"Fast, good for many objects"}),(0,r.jsx)(e.td,{children:"Gazebo, PyBullet"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"DART"})}),(0,r.jsx)(e.td,{children:"Accurate dynamics"}),(0,r.jsx)(e.td,{children:"Gazebo option"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"PhysX"})}),(0,r.jsx)(e.td,{children:"GPU-accelerated, real-time"}),(0,r.jsx)(e.td,{children:"Isaac Sim, Unity"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"MuJoCo"})}),(0,r.jsx)(e.td,{children:"Research-focused, accurate contacts"}),(0,r.jsx)(e.td,{children:"DeepMind"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"physics-engine-trade-offs",children:"Physics Engine Trade-offs"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"        Accuracy\n           \u25b2\n           \u2502\n    MuJoCo \u2502    DART\n           \u2502\n           \u2502    ODE\n           \u2502              Bullet\n           \u2502                      PhysX\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Speed\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Choosing a physics engine:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Control algorithm development"}),": Choose accuracy (MuJoCo, DART)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Multi-robot simulation"}),": Choose speed (Bullet, PhysX)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"RL training at scale"}),": Choose GPU acceleration (PhysX)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"simulation-step-size",children:"Simulation Step Size"}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.strong,{children:"time step"})," affects accuracy and stability:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="Step size considerations"',children:"# Small step = more accurate but slower\nphysics_step = 0.001  # 1ms, 1000 steps per second\n\n# Large step = faster but may be unstable\nphysics_step = 0.01   # 10ms, 100 steps per second\n\n# Typical robotics simulation\nphysics_step = 0.001 to 0.004  # 1-4ms\n"})}),"\n",(0,r.jsx)(e.admonition,{title:"Stability",type:"warning",children:(0,r.jsx)(e.p,{children:"Large time steps can cause unstable simulations where objects explode or pass through each other. Start with small steps and increase only if needed for speed."})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"sensor-modeling",children:"Sensor Modeling"}),"\n",(0,r.jsx)(e.h3,{id:"sensor-model-components",children:"Sensor Model Components"}),"\n",(0,r.jsx)(e.p,{children:"A realistic sensor model includes:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Ideal measurement"}),": Perfect sensor reading"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Systematic errors"}),": Bias, scale factor, misalignment"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Random errors"}),": Gaussian noise, quantization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physical effects"}),": Occlusion, reflections, motion blur"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"camera-simulation",children:"Camera Simulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="Camera noise model"',children:'import numpy as np\n\ndef simulate_camera(ideal_image, params):\n    """Add realistic noise to camera image."""\n    # Gaussian noise (sensor noise)\n    noise = np.random.normal(0, params.noise_std, ideal_image.shape)\n\n    # Quantization (8-bit ADC)\n    noisy = ideal_image + noise\n    quantized = np.clip(noisy, 0, 255).astype(np.uint8)\n\n    # Motion blur (if camera moving)\n    if params.exposure_time > 0:\n        quantized = apply_motion_blur(quantized, params.velocity)\n\n    return quantized\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Camera parameters to model:"})}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Parameter"}),(0,r.jsx)(e.th,{children:"Description"}),(0,r.jsx)(e.th,{children:"Typical Value"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Resolution"}),(0,r.jsx)(e.td,{children:"Image size"}),(0,r.jsx)(e.td,{children:"640x480 to 4K"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"FOV"}),(0,r.jsx)(e.td,{children:"Field of view"}),(0,r.jsx)(e.td,{children:"60-120 degrees"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Frame rate"}),(0,r.jsx)(e.td,{children:"FPS"}),(0,r.jsx)(e.td,{children:"30-60 Hz"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Noise"}),(0,r.jsx)(e.td,{children:"Sensor noise"}),(0,r.jsx)(e.td,{children:"SNR 30-50 dB"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Latency"}),(0,r.jsx)(e.td,{children:"Processing delay"}),(0,r.jsx)(e.td,{children:"10-50 ms"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"lidar-simulation",children:"LiDAR Simulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="LiDAR noise model"',children:'def simulate_lidar(ideal_ranges, params):\n    """Add realistic noise to LiDAR ranges."""\n    ranges = ideal_ranges.copy()\n\n    # Range-dependent Gaussian noise\n    noise_std = params.base_noise + params.range_factor * ranges\n    noise = np.random.normal(0, noise_std)\n    ranges += noise\n\n    # Random dropouts (missed returns)\n    dropout_mask = np.random.random(ranges.shape) < params.dropout_rate\n    ranges[dropout_mask] = np.inf\n\n    # Beam divergence (averaging at distance)\n    # ... additional effects\n\n    return ranges\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"LiDAR parameters:"})}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Parameter"}),(0,r.jsx)(e.th,{children:"Description"}),(0,r.jsx)(e.th,{children:"Typical Value"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Channels"}),(0,r.jsx)(e.td,{children:"Vertical beams"}),(0,r.jsx)(e.td,{children:"16, 32, 64, 128"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Points/sec"}),(0,r.jsx)(e.td,{children:"Scan rate"}),(0,r.jsx)(e.td,{children:"300K - 2M"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Range"}),(0,r.jsx)(e.td,{children:"Max distance"}),(0,r.jsx)(e.td,{children:"50-200 m"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Accuracy"}),(0,r.jsx)(e.td,{children:"Range error"}),(0,r.jsx)(e.td,{children:"\xb12-5 cm"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Angular resolution"}),(0,r.jsx)(e.td,{children:"Beam spacing"}),(0,r.jsx)(e.td,{children:"0.1-0.4 degrees"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"imu-simulation",children:"IMU Simulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="IMU noise model"',children:'class IMUSimulator:\n    def __init__(self, params):\n        self.gyro_bias = np.zeros(3)\n        self.accel_bias = np.zeros(3)\n        self.params = params\n\n    def update(self, true_angular_vel, true_linear_accel, dt):\n        """Simulate IMU measurements with noise."""\n        # Bias random walk\n        self.gyro_bias += np.random.normal(\n            0, self.params.gyro_bias_instability * np.sqrt(dt), 3\n        )\n        self.accel_bias += np.random.normal(\n            0, self.params.accel_bias_instability * np.sqrt(dt), 3\n        )\n\n        # Add bias and white noise\n        gyro = true_angular_vel + self.gyro_bias + \\\n               np.random.normal(0, self.params.gyro_noise, 3)\n\n        accel = true_linear_accel + self.accel_bias + \\\n                np.random.normal(0, self.params.accel_noise, 3)\n\n        return gyro, accel\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,r.jsx)(e.h3,{id:"what-is-domain-randomization",children:"What is Domain Randomization?"}),"\n",(0,r.jsx)(e.p,{children:"Domain randomization trains AI models on varied simulated environments so they generalize to the real world."}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key insight"}),": If a model works across many random simulations, it will likely work in reality (which is just one more variation)."]}),"\n",(0,r.jsx)(e.h3,{id:"types-of-randomization",children:"Types of Randomization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Domain Randomization                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                              \u2502\n\u2502   Visual Randomization          Physics Randomization        \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502   \u2502 \u2022 Textures          \u2502      \u2502 \u2022 Mass/Inertia      \u2502      \u2502\n\u2502   \u2502 \u2022 Lighting          \u2502      \u2502 \u2022 Friction          \u2502      \u2502\n\u2502   \u2502 \u2022 Camera position   \u2502      \u2502 \u2022 Joint damping     \u2502      \u2502\n\u2502   \u2502 \u2022 Colors            \u2502      \u2502 \u2022 Motor strength    \u2502      \u2502\n\u2502   \u2502 \u2022 Backgrounds       \u2502      \u2502 \u2022 Sensor noise      \u2502      \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                              \u2502\n\u2502   Dynamics Randomization       Environment Randomization     \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502   \u2502 \u2022 Action delays     \u2502      \u2502 \u2022 Object positions  \u2502      \u2502\n\u2502   \u2502 \u2022 Observation noise \u2502      \u2502 \u2022 Obstacle shapes   \u2502      \u2502\n\u2502   \u2502 \u2022 Control frequency \u2502      \u2502 \u2022 Terrain           \u2502      \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h3,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="domain_randomization.py"',children:'import numpy as np\n\nclass DomainRandomizer:\n    """Randomize simulation parameters for robust training."""\n\n    def __init__(self, config):\n        self.config = config\n\n    def randomize_physics(self, robot):\n        """Randomize robot physical properties."""\n        # Mass: \xb120%\n        for link in robot.links:\n            scale = np.random.uniform(0.8, 1.2)\n            link.mass *= scale\n\n        # Friction: 0.5 to 1.5\n        for link in robot.links:\n            link.friction = np.random.uniform(0.5, 1.5)\n\n        # Joint damping: \xb130%\n        for joint in robot.joints:\n            scale = np.random.uniform(0.7, 1.3)\n            joint.damping *= scale\n\n    def randomize_visuals(self, scene):\n        """Randomize visual appearance."""\n        # Lighting direction\n        scene.light_direction = np.random.uniform(-1, 1, 3)\n        scene.light_direction /= np.linalg.norm(scene.light_direction)\n\n        # Light intensity\n        scene.light_intensity = np.random.uniform(0.5, 1.5)\n\n        # Random textures\n        for obj in scene.objects:\n            obj.texture = np.random.choice(self.config.textures)\n\n    def randomize_sensors(self, robot):\n        """Randomize sensor characteristics."""\n        # Camera noise level\n        robot.camera.noise_std = np.random.uniform(0.01, 0.05)\n\n        # LiDAR dropout rate\n        robot.lidar.dropout_rate = np.random.uniform(0.0, 0.1)\n\n        # IMU bias\n        robot.imu.gyro_bias = np.random.normal(0, 0.01, 3)\n'})}),"\n",(0,r.jsx)(e.h3,{id:"curriculum-learning",children:"Curriculum Learning"}),"\n",(0,r.jsx)(e.p,{children:"Start simple, increase randomization over training:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="curriculum.py"',children:'def get_randomization_scale(training_step, max_steps):\n    """Gradually increase randomization."""\n    progress = training_step / max_steps\n\n    # Linear curriculum\n    return min(1.0, progress * 2.0)  # Full randomization at 50%\n\n# Usage\nscale = get_randomization_scale(current_step, total_steps)\nrandomizer.randomize_physics(robot, scale=scale)\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"sim-to-real-transfer",children:"Sim-to-Real Transfer"}),"\n",(0,r.jsx)(e.h3,{id:"the-reality-gap",children:"The Reality Gap"}),"\n",(0,r.jsx)(e.p,{children:"Simulations never perfectly match reality. Common differences:"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Aspect"}),(0,r.jsx)(e.th,{children:"Simulation"}),(0,r.jsx)(e.th,{children:"Reality"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Physics"}),(0,r.jsx)(e.td,{children:"Approximated"}),(0,r.jsx)(e.td,{children:"Complex, unknown"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Sensors"}),(0,r.jsx)(e.td,{children:"Modeled noise"}),(0,r.jsx)(e.td,{children:"True noise distribution"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Actuators"}),(0,r.jsx)(e.td,{children:"Ideal response"}),(0,r.jsx)(e.td,{children:"Delays, nonlinearities"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Environment"}),(0,r.jsx)(e.td,{children:"Simplified"}),(0,r.jsx)(e.td,{children:"Cluttered, dynamic"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"transfer-techniques",children:"Transfer Techniques"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. System Identification"})}),"\n",(0,r.jsx)(e.p,{children:"Measure real robot properties and match simulation:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="system_identification.py"',children:'def identify_motor_dynamics(real_robot):\n    """Measure motor response characteristics."""\n    # Send step commands, measure response\n    command = 1.0  # rad/s\n    real_robot.set_velocity_command(command)\n\n    response = []\n    for t in range(100):\n        response.append(real_robot.get_velocity())\n        time.sleep(0.01)\n\n    # Fit first-order system: tau * dv/dt + v = K * command\n    tau, K = fit_first_order(response, command)\n\n    return {\'time_constant\': tau, \'gain\': K}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Domain Adaptation"})}),"\n",(0,r.jsx)(e.p,{children:"Adapt model to real domain after simulation training:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Train in   \u2502        \u2502   Fine-tune \u2502        \u2502  Deploy on  \u2502\n\u2502 Simulation  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  on Real    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502 Real Robot  \u2502\n\u2502             \u2502        \u2502    Data     \u2502        \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     100K episodes         100 episodes           Production\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"3. Reality-Aware Training"})}),"\n",(0,r.jsx)(e.p,{children:"Include real data during simulation training:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="mixed_training.py"',children:'def get_training_batch(sim_buffer, real_buffer, real_ratio=0.1):\n    """Mix simulation and real data."""\n    batch_size = 256\n    real_samples = int(batch_size * real_ratio)\n    sim_samples = batch_size - real_samples\n\n    sim_batch = sim_buffer.sample(sim_samples)\n    real_batch = real_buffer.sample(real_samples)\n\n    return concatenate(sim_batch, real_batch)\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"choosing-simulation-fidelity",children:"Choosing Simulation Fidelity"}),"\n",(0,r.jsx)(e.h3,{id:"fidelity-levels",children:"Fidelity Levels"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Level"}),(0,r.jsx)(e.th,{children:"Description"}),(0,r.jsx)(e.th,{children:"Use Case"}),(0,r.jsx)(e.th,{children:"Speed"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Kinematic"})}),(0,r.jsx)(e.td,{children:"Positions only, no physics"}),(0,r.jsx)(e.td,{children:"Path planning"}),(0,r.jsx)(e.td,{children:"Very fast"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Dynamic"})}),(0,r.jsx)(e.td,{children:"Basic physics, simple contacts"}),(0,r.jsx)(e.td,{children:"Control testing"}),(0,r.jsx)(e.td,{children:"Fast"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Detailed"})}),(0,r.jsx)(e.td,{children:"Full physics, friction"}),(0,r.jsx)(e.td,{children:"RL training"}),(0,r.jsx)(e.td,{children:"Medium"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Photorealistic"})}),(0,r.jsx)(e.td,{children:"Ray tracing, materials"}),(0,r.jsx)(e.td,{children:"Perception training"}),(0,r.jsx)(e.td,{children:"Slow"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"matching-fidelity-to-task",children:"Matching Fidelity to Task"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",metastring:'title="fidelity_selection.py"',children:"def select_fidelity(task_type):\n    \"\"\"Choose appropriate simulation fidelity.\"\"\"\n\n    if task_type == 'path_planning':\n        return {\n            'physics': 'kinematic',\n            'rendering': 'none',\n            'sensors': 'ideal',\n            'expected_rtf': 10000\n        }\n\n    elif task_type == 'control_development':\n        return {\n            'physics': 'dynamic',\n            'rendering': 'basic',\n            'sensors': 'noisy',\n            'expected_rtf': 100\n        }\n\n    elif task_type == 'rl_training':\n        return {\n            'physics': 'detailed',\n            'rendering': 'basic',\n            'sensors': 'noisy',\n            'expected_rtf': 10\n        }\n\n    elif task_type == 'perception_training':\n        return {\n            'physics': 'detailed',\n            'rendering': 'photorealistic',\n            'sensors': 'realistic',\n            'expected_rtf': 0.1\n        }\n"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"exercise-1-sensor-noise-analysis",children:"Exercise 1: Sensor Noise Analysis"}),"\n",(0,r.jsxs)(e.admonition,{title:"Exercise 1: Compare Ideal vs Noisy Sensors",type:"tip",children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Objective"}),": Understand how sensor noise affects robot perception."]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Time Estimate"}),": 30 minutes"]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Steps"}),":"]}),(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Create a Python script that simulates LiDAR readings"}),"\n",(0,r.jsx)(e.li,{children:"Generate ideal readings for a simple room (4 walls)"}),"\n",(0,r.jsx)(e.li,{children:"Add Gaussian noise with different standard deviations"}),"\n",(0,r.jsx)(e.li,{children:"Visualize how noise affects wall detection"}),"\n",(0,r.jsx)(e.li,{children:"Calculate error statistics"}),"\n"]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Starter Code"}),":"]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\ndef generate_ideal_lidar(room_size, num_beams=360):\n    """Generate ideal LiDAR readings for a rectangular room."""\n    angles = np.linspace(0, 2*np.pi, num_beams, endpoint=False)\n    ranges = []\n\n    for angle in angles:\n        # Calculate intersection with walls\n        # ... implement ray-wall intersection\n        pass\n\n    return angles, np.array(ranges)\n\ndef add_noise(ranges, noise_std):\n    """Add Gaussian noise to ranges."""\n    return ranges + np.random.normal(0, noise_std, ranges.shape)\n\n# Generate and compare\nangles, ideal = generate_ideal_lidar((10, 10))\nnoisy_01 = add_noise(ideal, 0.01)  # 1cm noise\nnoisy_05 = add_noise(ideal, 0.05)  # 5cm noise\n\n# Visualize in polar coordinates\n# ...\n'})}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected Result"}),": Visualization showing how noise distorts the room shape, with error statistics."]})]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"exercise-2-domain-randomization-experiment",children:"Exercise 2: Domain Randomization Experiment"}),"\n",(0,r.jsxs)(e.admonition,{title:"Exercise 2: Test Randomization Effects",type:"tip",children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Objective"}),": Observe how domain randomization helps generalization."]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Time Estimate"}),": 45 minutes"]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Steps"}),":"]}),(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Create a simple simulated sensor that detects objects"}),"\n",(0,r.jsx)(e.li,{children:"Train a classifier on fixed simulation settings"}),"\n",(0,r.jsx)(e.li,{children:"Train another classifier with domain randomization"}),"\n",(0,r.jsx)(e.li,{children:'Test both on "unseen" settings'}),"\n",(0,r.jsx)(e.li,{children:"Compare generalization performance"}),"\n"]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key Insight"}),": The randomized model should perform better on varied test conditions."]}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Expected Outcome"}),":"]}),(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Fixed training accuracy: 95%\nFixed test accuracy (new conditions): 60%\n\nRandomized training accuracy: 85%\nRandomized test accuracy (new conditions): 80%\n"})})]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"In this chapter, you learned:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physics engines"}),": ODE, Bullet, PhysX - trade accuracy for speed"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sensor modeling"}),": Add realistic noise for cameras, LiDAR, IMU"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Domain randomization"}),": Vary simulation to improve real-world transfer"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sim-to-real"}),": System identification, adaptation, reality-aware training"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fidelity selection"}),": Match simulation complexity to your task"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["These concepts apply to all simulators. In the next chapter, you'll apply them using ",(0,r.jsx)(e.a,{href:"/docs/module-2/gazebo-basics",children:"Gazebo Basics"}),"."]}),"\n",(0,r.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://arxiv.org/abs/1703.06907",children:"OpenAI Domain Randomization Paper"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://arxiv.org/abs/2009.13303",children:"Sim-to-Real Robot Learning Survey"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://mujoco.readthedocs.io/",children:"MuJoCo Physics Documentation"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://developer.nvidia.com/isaac-sim",children:"NVIDIA Isaac Sim Replicator"})}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>l});var s=i(6540);const r={},t=s.createContext(r);function a(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);